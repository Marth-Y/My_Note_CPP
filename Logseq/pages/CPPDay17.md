- # 一、C++模板--浅尝辄止
	- 囫囵吞枣
	- 只有在需要写第三方库
	- 泛型编程
		- 模板元编程-->最难的
			- 如IO流、容器都是模板元编程
			- 如果要理解，就需要多读源码
			- 推荐《STL源码剖析》
- # 二、模板
	- **为什么要定义模板**
		- 当程序员在实现代码的过程中，当一个函数的定义只有参数不同，而其他的所有代码都是相同的情况下，写出来的代码有大量重复的内容，因此诞生了一个思想：希望将类型参数化，因而产生了模板。
		- **是泛型编程的体现-->抽象级别高于面向对象**
		- 模板的实现的提出：基于类型参数化的思想
	- 编程语言的特点：
		- C、C++、Java、C# 等等语言，是编译型语言，有一个**强大的类型系统**，希望在程序执行之前，尽可能的发现错误，防止错误被延迟到运行时。会对语言本身的使用造成一些限制（**静态语言，强类型的语言**）
		- 为了解决语言本身的**灵活性与限制**的冲突，C++提供了函数重载和运算符重载以及模板来予以解决
		- 还有另外一类语言，解释型语言，shell、lua、javascript、python、golang，在使用的过程中，一个变量可以表达多种类型。**动态语言，弱类型的语言**。Javascript中所有的类型都可以用let来声明，Python中使用一个变量时，根本就不需要声明。
		- ==**C++与python  AI领域**==
			- 智能汽车、万物互联
		- ==**C++与golang  在服务器编程领域**== -->新趋势
			- C++主打的性能，接近系统编程
			- python、golang接近业务，**可以快速的实现一些业务**
	- **形式**
		- 形式：`template <typename/class T1,typename T2,...>`   <>模板形参列表
	- **函数模板的实例化：**
		- 显式实例化
			- 如`add<int>(1,3)`在函数名之后，直接加上<>模板实参列表，显式的告诉编译器需要生成一个int类型的add函数
		- 隐式实例化
			- 由编译器自己推导类型
			- ```CPP
			  cout << "add(ia, ib) = " << add(ia, ib) << endl;//隐式实例化，没有明确说明类型，靠
			  编译器推导
			  cout << "add(da, db) = " << add<double>(da, db) << endl;//显示实例化，编译器无序
			  推导
			  ```
	- **由于在函数模板的定义中，只有一个T类型，因此在实参传递时，不能传递不同类型的实参，否则会在编译时报错。**
	- **函数模板的重载**
		- 函数模板与普通函数可以进行重载
			- 普通函数会优先执行
		- 函数模板之间也可以进行重载
	- **分类**
		- 模板可以分为函数模板和类模板
		- 函数模板-->生成-->模板函数
		- 类模板-->模板类
			- 这是一个实例化的过程。通过模板参数推导完成
		- 其实现原理：==模板参数推导==
			- **模板函数的生成是在编译器扫描到实参传递时的类型而自动生成的。**不需要程序员手写。
			- 因此可以把模板看成是一个代码生成器
	- **为什么C++头文件没有所谓的.h后缀？**
		- 在C++发展历史过程中，最开始是有.h的后缀的，到了后来就被取消掉了，原因就在于模板的实现
		- 规定（约定-编程规范）：
			- 自定义C++头文件后缀都用**\*.hpp/\*.hh**来表示
			- 自定义C头文件的后缀，采用*.h来表示
	- class关键字的第二种用法：作为模板参数的标志
	- 函数模板可以分为声明与实现
		- ```CPP
		  template<class T>
		  T add(T x,T y);//函数模板的声明
		  
		  template<class T>
		  T add(T x,T y)//函数模板的实现
		  {
		    	return x+y;
		  }
		  ```
		- 当声明与实现在一个头文件中时，是没有问题的，可以这样做
		- 当声明与实现在不同的头文件中时，是有问题的，编译无法通过
			- 编译时，是以模块为单位的，一个模块就是一个.cc的文件；每一个模块编译完毕之后，再去进行链接操作
				- 解析：预处理时展开头文件，.hpp的函数模板声明加入main文件，编译时，分模块编译，因为main中有模板函数调用，函数模板会进行类型推导，生成一个模板函数声明（不会链接起来），而.cc文件中由于没有函数的调用，不会产生模板参数类型推导产生代码，所以就没有int add函数的实现了，因而链接时有未定义的错误，而且是链接阶段报错。
			- 这意味着，当我们对一个.cc文件进行编译时，**必须要看到一个完整的模板的定义**，如果看不到就会报未定义的错误
		- 但是我们还是想分离：就反其道而行之，在.hpp中函数模板声明下包含.cc实现文件（或文件末尾，反正实现在声明下面），这样预处理就会展开成一个完整的实现。在main中包含.hpp文件。但此时.hpp已经是一个完整的实现文件了。所以将这种文件的.hpp去掉，将模板实现文件后缀改为.tcc表示模板实现文件（也因为他不是一个完整的模块，单独的没有用，不会生成代码）。所以C++中头文件没有.hpp了。
		- **总结**：当模板的实现需要分成声明与实现时，必须要在头文件中，include实现文件。
	- **函数模板的问题**
		- 函数模板的通用形式无法解决`const char*`类型的实现，因为他们无法进行加法操作（指针不能相加），函数模板出现了bug，该怎么办？
		- ```CPP
		  //函数模板的通用版本
		  template <typename T>
		  T add(T x,T y)
		  {
		    	return x + y;
		  }
		  
		  void test0()
		  {
		    	const char* ptr1 = "hello";
		     	const char* ptr2 = "wuhan";
		  	add(ptr1,ptr2);
		  }
		  
		  //方案1:函数重载
		  const char* add(const char* x,const char* y)
		  {
		    	char* ptmp = new char[strlen(x) + strlen(y) + 1]();
		    	strcpy(ptmp,x);
		    	strcpy(ptmp,y);
		    	return ptmp;
		  }
		  
		  //方案2：模板的特化：
		  //1.全特化
		  //2.偏特化
		  
		  //全特化
		  template<>
		  const char* add<const char*>(const char* x,const char* y)
		  {
		    	char* ptmp = new char[strlen(x) + strlen(y) + 1]();
		    	strcpy(ptmp,x);
		    	strcpy(ptmp,y);
		    	return ptmp;
		  }
		  ```
		- 解决方案：
			- 1.重载const char*形式的普通函数
			- 2.采用**模板的特化(Specialization)**版本：特化版本必须放在通用版本之后。
				- 全特化
					- 对所有的模板参数指定具体类型
				- 偏特化
					- 对部分的模板参数指定具体类型
	- **模板参数**
		- 模板参数可以分为两类
			- 1.类型参数
			- 2.非类型参数，常量表达式。就是整型数据。
				- 整型：bool/char/short/int/long/long long
			- 模板参数也可以设置默认值
			- ```CPP
			  template <typename T = int, int kBase = 10>//模板参数可以设置默认值
			  T multiply(T x, T y)
			  {
			  	return x * y * kBase;
			  }
			  
			  void test0()
			  {
			    	int a = 10,b = 20;
			    	//没有设置默认值时非类型参数的值必须要在模板实参列表中进行实参传递时显式给出
			    	cout<<multiply<int,8>(a,b)<<endl;
			    	//设置默认值后：
			    	cout<<multiply(a,b)<<endl;
			    	//cout<<multiply<,10>(a,b)<<endl;//error虽然T有默认值，但是不能这么写，就像函数默认参数匹配一样
			    	//参数匹配只能从后往前。
			  }
			  
			  ```
	- **执行的性能没有损失，但是有一个问题：编译速度很慢**
		- 因为模板要生成代码嘛。
		- 因此推出module模块化 -->C++20以后可以看为一个新的物种。
	- **成员函数模板**
		- 成员函数本身也是可以作为函数模板，称为成员函数模板。
	- **类模板**
		- ```CPP
		  template<class T1,...,class TN>
		  class name
		  {
		    
		  };
		  ```
		- 当定义了一个类模板的时候，每一个成员函数如果要放在类之外实现，则必须要在每一个成员函数的返回值前面加上模板参数形参列表。同时还要在类作用域之后加上模板参数列表。
	- **可变模板参数**
		- 1.可变参数
			- C语言中写法:
			- C语言中对于可变参数的使用，会涉及到va_list；都是通过指针操作完成，很容易出错
		- 2.C++11中推出了可变模板参数
			- ```cpp
			  template<class... Args>//Args模板参数包
			  void func(Args... args);//args函数参数包
			  ```
			- ```CPP
			  template<class... Args>
			  void print(Args... args)
			  {
			    	//求取可变模板参数的个数
			    	cout << sizeof...(Args) << endl;
			    	cout << sizeof...(args) << endl;
			  }
			  void test0()
			  {
			    	//可变模板参数可以代表0个或者多个参数
			    	print();
			    	print(1,'a',"hello",90.2);
			  }
			  //出口函数1
			  void display()
			  {
			    //display出口函数,因为最后包中没有数据了，就会调用这个函数，最后依次返回退出。
			    //深度优先遍历了，类似
			  }
			  
			  //出口函数2：模板样子
			  template<class T>
			  void display(T t)
			  {
			    	cout << t << " ";
			    	//到display(t),最后一个参数后就依次返回退出了。比1少了一次调用。
			  }
			  
			  //当...在模板（函数）参数包的左边时，表示打包
			  //当...在模板（函数）参数包的右边时，表示解包
			  template<class T,class... Args>
			  void display(T t,Args... args)//1, N - 1
			  {
			    	cout << t << " ";
			    	display(args...)//调用时就得将包拆开，一件件去传递
			  }
			  
			  void test1()
			  {
			    	display(1,'a',2.2,"hello");
			  }
			  ```
		- 可变模板参数解决了传递参数的问题，方便后续的调用
- # 智能指针再探
	- ==16：26==
	- 对于某一类型的堆空间的对象进行回收
		- 使用函数对象进行回收
		- RAII.cc
		- 尝试特例化解决文件指针回收
		- deleter.cc
		- `unique_ptr/shared_ptr`指定删除器
			- 对于`uniquee_ptr`通过指定第二个模板参数来设置删除器
			- `shared_ptr`通过构造函数的第二个参数来设置删除器。
- # 智能指针的误用
	- ```CPP
	  Point *pt = new Point(10, 20);
	  unique_ptr<Point> up1(pt);
	  unique_ptr<Point> up2(pt);//error double free
	  
	  shared_ptr<Point> up1(pt);
	  shared_ptr<Point> up2(pt);//error double free
	  //没有复制操作，所以不涉及引用计数哦。就是两个智能指针托管了同一个对象
	  //为什么创建不增加引用计数？莫问，现象就这样设计的
	  ```
	-