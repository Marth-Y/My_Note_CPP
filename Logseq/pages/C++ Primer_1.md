title:: C++ Primer_1

- ## 基础知识
  id:: d14e2a1d-4393-4c78-9443-4b66054c92a4
  collapsed:: true
	- ### 1.2 初试输入输出
	  id:: e45aa92c-a7a8-4c19-b7fb-e90d3dc9a68f
		- 运算符endl
			- 这是一个被称为**操纵符(manipulator)**的特殊值。写入endl的效果是结束当前行，并将与设备关联的缓冲区(buffer)中的内容刷到设备中。缓冲刷新操作可以保证到目前为止程序所产生的所有输出都真正写入到输出流中，而不是仅仅停留在内存中。
			- P32
			- 补充:endl不仅可以换行，还可以刷新缓冲区，把缓冲区内容写入到输出流中。
			- cerr<<
			- clog<<
	- ### 1.3 注释简介
	  id:: 79ce7a03-5008-4204-ae32-4ee73ac59f75
		- /\* \*/注释不能嵌套另一个/\* \*/注释
	- ### 1.4 控制流
	  id:: c26f4c83-efc2-4407-b40b-f5440f5dfe95
		- 读取数量不定的输入时，可以用：
		  ```Cpp
		  int value;
		  while(cin>>value){}
		  ```
		- 此循环实际上检测的是cin。当我们使用istream对象作为条件时，其效果是检测流的状态。如果流是有效的，即流未遇到错误，那么检测成果。当遇到文件结束符(end-of-file)，或遇到一个无效的输入时（输入错误），istream对象的状态就会变为无效。处于无效状态的istream对象会使条件变为假。
		- P39
		- 常见的编译器可以检查出的错误
			- 1.语法错误
			- 2.类型错误
				- 如int型参数传给函数string形参
			- 3.声明错误
				- (1)来自标准库的名字忘记使用std\:\:
				- (2)标识符名字拼写错误
- ## 第Ⅰ部分 C++基础
  id:: 625feb03-7640-4fc0-9432-0365abce0c61
	- ### 第2章 变量和基本类型
	  id:: 625feb1e-9d99-4e2a-bfdf-d49435a09e75
		- #### 2.1基本内置类型
		  id:: 6260cf30-e72d-4af2-bb30-0e3ee70aef3b
		  collapsed:: true
			- ##### 2.1.1算术类型
			  id:: 6260cf66-9aeb-4591-9a5b-21135a50af4a
			  collapsed:: true
				- C++定义了一套包括算术类型（arithmetic type）和空类型（void）在内的基本数据类型。其中算术类型包含了字符、整型数、布尔值和浮点数。空类型不对应具体的值，仅用于一些特殊的场合。
					- 提问：C++的基本数据类型？
					- 回答：算术类型和空类型。
					- 补充：整型、浮点型、字符、布尔都属于算术类型。void是空类型。
				- 算术类型分为两类：整型（integral type，包括字符和布尔类型在内）和浮点型。
				- 与其他整型不同，字符型被分为了三种：char、signed char和unsigned char。特别需要注意的是：类型char和类型signedchar并不一样。尽管字符型有三种，但是字符的表现形式却只有两种：带符号的和无符号的。类型char实际上会表现为上述两种形式中的一种，具体是哪种由编译器决定。
				- C++标准并没有规定带符号类型应如何表示，但是约定了在表示范围内正值和负值的量应该平衡。因此，8比特的signedchar理论上应该可以表示-127至127区间内的值，大多数现代计算机将实际的表示范围定为-128至127。
					- 提问：为什么是-128，不对称？
					- 回答：计算机内存中存储数据的补码形式，补码的表示范围就是这样，他不能表示+128，127+1会溢出变为-128.
				- 类型选择经验：
					- 当明确知晓数值不可能为负时，选用无符号类型。
					- 使用int执行整数运算。在实际应用中，short常常显得太小而long一般和int有一样的尺寸。如果你的数值超过了int的表示范围，选用long long。
					- 在算术表达式中不要使用char或bool，只有在存放字符或布尔值时才使用它们。因为类型char在一些机器上是有符号的，而在另一些机器上又是无符号的，所以如果使用char进行运算特别容易出问题。如果你需要使用一个不大的整数，那么明确指定它的类型是signed char或者unsigned char。
					- 执行浮点数运算选用double，这是因为float通常精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几。事实上，对于某些机器来说，双精度运算甚至比单精度还快。long double提供的精度在一般情况下是没有必要的，况且它带来的运行时消耗也不容忽视。
			- ##### 2.1.2类型转换
			  id:: 6260cef0-f298-4c8d-bc20-bea6b48692c0
				- 类型所能表示的值的范围决定了转换的过程：
					- 当我们把一个非布尔类型的算术值赋给布尔类型时，初始值为0则结果为false，否则结果为true。
					- 当我们把一个布尔值赋给非布尔类型时，初始值为false则结果为0，初始值为true则结果为1。
					- 当我们把一个浮点数赋给整数类型时，截断保留整数部分。
					- 当我们把一个整数值赋给浮点类型时，小数部分记为0。如果该整数所占的空间超过了浮点类型的容量，精度可能有损失。
					- 当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。例如，8比特大小的unsigned char可以表示0至255区间内的值，如果我们赋了一个区间以外的值，则实际的结果是该值对256取模后所得的余数。因此，把-1赋给8比特大小的unsigned char所得的结果是255。
					- 当我们赋给带符号类型一个超出它表示范围的值时，结果是未定义的（undefined）。此时，程序可能继续工作、可能崩溃，也可能生成垃圾数据。
				- 程序也应该尽量避免依赖于实现环境的行为。如果我们把int的尺寸看成是一个确定不变的已知值，那么这样的程序就称作不可移植的（nonportable）。当程序移植到别的机器上后，依赖于实现环境的程序就可能发生错误。要从过去的代码中定位这类错误可不是一件轻松愉快的工作。
				- 当从无符号数中减去一个值时，不管这个值是不是无符号数，我们都必须确保结果不能是一个负值：
					- ```CPP
					  unsigned u1=42,u2=10;
					  cout<<u1-u2<<endl; //正确：输出32
					  cout<<u2-u1<<endl; //正确：不过，结果不是负数，仍然是正数，10-42=-32，机器数对-32解析为正数。
					  ```
					- 所以我们不能写：for(unsigned i =10;i>=0;i--)i永远是正数，死循环。当i=0时，--i=-1，补码为：FFFF FFFF.解析为正数，数值为4294967295。就会死循环。
				- **提示：切勿混用带符号类型和无符号类型**
					- 因为带符号类型和无符号类型混合计算，带符号类型会隐式转换为无符号类型，这时负数就会出错。
			- ##### 2.1.3字面值常量
			  id:: 6260d518-5420-4236-b892-5a4d3e9fdfdd
				- 我们可以将整型字面值写作十进制数、八进制数或十六进制数的形式。以0开头的整数代表八进制数，以0x或0X开头的代表十六进制数。
					- 提问1：八进制、十六进制表示前缀？
					- 回答：八进制：0；十六进制：0x、0X
					- 提问2：八进制、十六进制输出？
					- 回答：C中八进制：%o；十六进制：%x
				- 浮点型字面值表现为一个小数或以科学计数法表示的指数，其中指数部分用E或e标识
					- 提问：浮点数表示？
					- 回答：浮点数输入应尽量采用科学计数法e；如0.0001：e-4
					- 补充：因为这样不容易出错，直接输入万一少输入个0呢。
					- 提问：浮点数内存如何存储？
					- 回答：IEEE754标准：数符m | 阶码E(移码表示，即指数部分) |尾数M(原码表示，小数部分，默认省略1. 。组成为：(-1^m) × 1.M × r^E)
				- 字符串字面值的类型实际上是由常量字符构成的数组（array），该类型将在3.5.4节（第109页）介绍。编译器在每个字符串的结尾处添加一个空字符（′\0′），因此，字符串字面值的实际长度要比它的内容多1。例如，字面值'A'表示的就是单独的字符A，而字符串"A"则代表了一个字符的数组，该数组包含两个字符：一个是字母A、另一个是空字符。
					- 提问：什么类型数据末尾会自动多加'\0'？
					- 回答：https://blog.csdn.net/sunnzhongg/article/details/53264175
				- nullptr是指针字面值，2.3.2节（第47页）将有更多关于指针和指针字面值的介绍。
		- #### 2.2变量
		  id:: 6260d9f7-c63f-48c2-9946-cea5efc90742
		  collapsed:: true
			- 变量提供一个具名的、可供程序操作的存储空间。C++中的每个变量都有其数据类型，数据类型决定着变量所占内存空间的大小和布局方式、该空间能存储的值的范围，以及变量能参与的运算。对C++程序员来说，“变量（variable）”和“对象（object）”一般可以互换使用。
			- ##### 2.2.1变量定义
			  id:: 6260da2e-3f58-48f1-92e9-d50f84874859
				- **术语：何为对象？**
				- C++程序员们在很多场合都会使用对象（object）这个名词。通常情况下，对象是指一块能存储数据并具有某种类型的内存空间。
					- 对象就是一个具有类型的内存空间。
				- 当一次定义了两个或多个变量时，对象的名字随着定义也就马上可以使用了。因此在同一条定义语句中，可以用先定义的变量值去初始化后定义的其他变量。
					- ```cpp
					  double i=56.56,j=i*10;//正确，因为i先定义。
					  ```
				- 定义于函数体内的内置类型的对象如果没有初始化，则其值未定义。类的对象如果没有显式地初始化，则其值由类确定。
					- 如果定义变量时没有初始化，将被赋予一个默认值。这个默认值因其类型、定义的位置而不同。一般内置类型由定义的位置决定：在函数体外默认值为0，函数体内没有初始化，则其值未定义，访问、拷贝都会出错。类自己决定对象的初始化方式。是否允许未初始化就定义对象也由类自己决定；绝大多数类支持无需显示初始化而定义对象，则类必须自己提供默认值，如string类，若未指定初始值，则赋予空串；若类要求显示初始化对象，则若创建对象时未显式初始化，将会出错。
					- ```cpp
					  std::string empty;//无需显式初始化而定义对象，empty自动被赋予空串。
					  ```
			- ##### 2.2.2变量声明和定义的关系
			  id:: 62635f19-ee26-4c7a-8f2d-4f1f8c257b8f
				- 为了支持分离式编译，C++语言将声明和定义区分开来。声明（declaration）使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而定义（definition）负责创建与名字关联的实体。
					- 就像.h和.cpp的关系，.h声明变量、函数、类、结构体等，.cpp实现，需要使用时，仅需引用.h文件。
				- 变量声明规定了变量的类型和名字，在这一点上定义与之相同。但是除此之外，定义还申请存储空间，也可能会为变量赋一个初始值。如果想声明一个变量而非定义它，就在变量名前添加关键字extern，而且不要显式地初始化变量：
					- ```cpp
					  extern int i;//声明i而非定义i
					  int j;//声明并定义j
					  ```
				- 任何包含了显式初始化的声明即成为定义。我们能给由extern关键字标记的变量赋一个初始值，但是这么做也就抵消了extern的作用。extern语句如果包含初始值就不再是声明，而变成定义了：
					- ```cpp
					  extern double pi = 3.1416;//定义
					  ```
				- 在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误。
		- #### 2.3复合类型
		  id:: 62636249-0150-450c-aaba-32b78d5db403
		  collapsed:: true
			- 复合类型（compound type）是指基于其他类型定义的类型。C++语言有几种复合类型，本章将介绍其中的两种：引用和指针。
				- 引用即别名。引用必须在定义时就初始化。引用不是一个对象，只是一个别名。定义后就不能再更改，和初始化的对象绑定在一起。
				- ```cpp
				  int val = 1;
				  int &relval = val;
				  
				  //TEST
				  int ival = 42;
				  int *p = &ival;
				  cout<<"*p="<<*p<<" "<<"p="<<p<<endl;
				  cout<<"&ival="<<&ival<<endl;
				  cout<<"ival="<<ival<<endl;
				  
				  /*
				  *p=42 p=0x61fe14
				  &ival=0x61fe14
				  ival=42
				  */
				  /*
				  p是int * 类型数据。p存的ival的地址，*p表示解析该地址的值，*是解引用符，表示得到指针p所指的对象。&表示取地址。
				  */
				  ```
			- 指针（pointer）是“指向（point to）”另外一种类型的复合类型。与引用类似，指针也实现了对其他对象的间接访问。然而指针与引用相比又有很多不同点。其一，指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。其二，指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。
			- 指针的值（即地址）应属下列4种状态之一：
				- 1.指向一个对象。
				- 2.指向紧邻对象所占空间的下一个位置。
				- 3.空指针，意味着指针没有指向任何对象。
				- 4.无效指针，也就是上述情况之外的其他值。
			- 像&和＊这样的符号，既能用作表达式里的运算符，也能作为声明的一部分出现，符号的上下文决定了符号的意义：
				- ```cpp
				  int i = 42;	
				  int &r = i;	//&紧随类型名出现，因此是声明的一部分。表示引用
				  int *p;		//*紧随类型名出现，p是一个指针。
				  p=&i;		//&出现在表达式中，是一个取地址符
				  *p=i;		//*出现在表达式中，是一个解引用符
				  int &r2 = *p;//&是声明的一部分，*是解引用符。
				  ```
			- void＊是一种特殊的指针类型，可用于存放任意对象的地址。
			- **指向指针的指针**
				- ```cpp
				      int ival = 42;
				      int *p = &ival;
				      int **pp = &p;
				      cout<<"*p="<<*p<<" "<<"p="<<p<<endl;
				      cout<<"&p="<<&p<<endl;
				      cout<<"pp="<<pp<<endl;
				      cout<<"*pp="<<*pp<<endl;
				      cout<<"**pp="<<**pp<<endl;
				  /*
				  *p=42 p=0x61fe14
				  &p=0x61fe08
				  pp=0x61fe08
				  *pp=0x61fe14
				  **pp=42
				  指向指针的指针，解引用一次为所指向指针的值，解引用两次为指针的指针所指向对象的值
				  */
				  ```
			- **指向指针的引用**
				- 引用不是一个对象，没有地址。所以不能定义一个指向引用的指针；但是指针是对象，可以定义指针的引用。
				- ```cpp
				      int ival = 42;
				      int *p;
				      int *&r = p;//r是一个对指针p的引用。*&r = p
				      r = &ival;//此时r是指针p的别名，r其实就是指针p
				      *r = 0;
				      cout<<*r<<" "<<ival<<endl;
				  /*
				  0 0
				  */
				  ```
			- 要理解r的类型到底是什么，最简单的办法是从右向左阅读r的定义。离变量名最近的符号（此例中是&r的符号&）对变量的类型有最直接的影响，因此r是一个引用。声明符的其余部分用以确定r引用的类型是什么，此例中的符号＊说明r引用的是一个指针。最后，声明的基本数据类型部分指出r引用的是一个int指针。
		- #### 2.4const限定符
		  id:: 62638220-6ff1-4d94-8986-dbc1231d2f18
		  collapsed:: true
			- 如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字。
			- **术语：常量引用是对const的引用**
				- 可以把引用绑定到const对象上，就像绑定到其他对象上一样，我们称之为对常量的引用
				- ```cpp
				  const int ci = 1024;
				  const int &r1 = ci;
				  ```
			- 引用的类型必须与其所引用对象的类型一致，但是有两个例外。第一种例外情况就是在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。尤其，允许为一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式：
				- ```cpp
				      double i=3.14;
				  
				      const int &val = i;//常量引用
				  
				      cout<<i<<" "<<val<<endl;
				      //3.14 3
				  
				      i = 5.56;	//常量引用可以绑定非常量对象，虽然常量引用不能修改值，但是可以用其他方式修改引用对象的值。
				  
				      cout<<i<<" "<<val<<endl;
				      //5.56 3
				  
				      //原因：被引用对象是double类型，常量引用是int型。在引用这个过程中，编译器会自动创建一个临时变量temp：
				      //const int temp = i;//生成临时量
				      //const int &val = temp;
				      //然后让引用val绑定临时量temp。故而修改原值，临时量不会变，所以引用不会变。
				      //如果val不是常量，这样引用自然希望通过引用可以修改值，但是这里只能修改临时量的值，因而这样做是非法的。
				  ```
		- #### 2.5处理类型
		  id:: 625ff3ee-f2a4-44eb-982e-f842d842635d
		  collapsed:: true
			- ##### 2.5.1类型别名
			  id:: 6271e9c3-7c6e-4552-b98b-59755f1b514a
			  collapsed:: true
				- 类型别名（type alias）是一个名字，它是某种类型的同义词
				- 有两种方法可用于定义类型别名。传统的方法是使用关键字typedef：
					- ```cpp
					  typedef double wages;	//wages是double类型的别名
					  typedef wages base,*p;//base是double的别名，*p是double*的别名
					  ```
					- 这里就明白了：typedef struct{ ... } LinkList*,LNode;后面是别名。
				- 新标准规定了一种新的方法，使用别名声明（alias declaration）来定义类型的别名：
					- ```cpp
					  using SI = Sales_item;//SI是Sales_item的同义词
					  ```
					- 这种方法用关键字using作为别名声明的开始，其后紧跟别名和等号，其作用是把等号左侧的名字规定成等号右侧类型的别名。
				- **指针、常量和类型别名**
					- 如果某个类型别名指代的是复合类型或常量，那么把它用到声明语句里就会产生意想不到的后果。
					- ```cpp
					  typedef char *pstring;
					  const pstring cstr = 0;//cstr是指向char的常量指针
					  const pstring *ps;//ps是一个指针，他的对象是指向char的常量指针
					  ```
					- const修饰pstring，而pstring是指向char的指针。所以pstring不能变，所以cstr是一个常量指针。ps是一个指针，所指对象是指向char类型的常量指针。
					- 不能将pstring换回char*类看，这样是一个错误的思想：`const char * cstr = 0`,这样cstr就是一个指针常量，所指的内容值不能变。其原因是因为：原句中`const pstring`是基本数据类型，而替换后`const char`变成了基本数据类型。
			- ##### 2.5.2auto类型说明符
			  id:: 6271ef7c-d212-4998-88cd-c4a2b811f80a
			  collapsed:: true
				- 和原来那些只对应一种特定类型的说明符（比如double）不同，auto让编译器通过初始值来推算变量的类型。显然，auto定义的变量必须有初始值：
					- ```cpp
					  auto item = val1+val2//item的类型由val1和val2和的类型决定
					  ```
				- 使用auto也能在一条语句中声明多个变量。因为一条声明语句只能有一个基本数据类型，所以该语句中所有变量的初始基本数据类型都必须一样：
					- ```cpp
					  auto i = ,*p = &i;//正确，i是整型，p是整型指针
					  auto sz = ,pi =3.14; //错误，类型不一致
					  ```
			- ##### 2.5.3decltype类型指示符
			  id:: 6271f23c-6419-4179-9e98-2b16501e5d5a
				- C++11新标准引入了第二种类型说明符decltype，它的作用是选择并返回操作数的数据类型。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值：
					- ```cpp
					  decltype(f()) sum = x;
					  ```
					- 编译器并不实际调用函数f，而是使用当调用发生时f的返回值类型作为sum的类型。换句话说，编译器为sum指定的类型是什么呢？就是假如f被调用的话将会返回的那个类型。
				- **切记**：decltype（（variable））（注意是双层括号）的结果永远是引用，而decltype（variable）结果只有当variable本身就是一个引用时才是引用。
		- #### 2.6自定义数据结构
		  id:: 6271f6e5-3e8f-436a-9785-144fc70f2fef
			- ##### 2.6.1定义Sales_data类型
			  id:: 6271f6f1-08fe-4c99-ab30-2a76baa57ea7
				- 类体右侧的表示结束的花括号后必须写一个分号，这是因为类体后面可以紧跟变量名以示对该类型对象的定义，所以分号必不可少：
				- ```cpp
				  struct Sales_data {...}accum,trans,*salesptr;
				  //等价于：
				  struct Sales_data {...};
				  Sales_data accum,trans,*salesptr;
				  ```
				- 类的数据成员定义了类的对象的具体内容，**每个对象有自己的一份数据成员拷贝**。
					- const修饰，所有对象只有一份。
			- ##### 2.6.3编写自己的头文件
			  id:: 6271f7cc-3c87-483d-9b53-3e12dfb1fa9b
				- ^^预处理器概述^^
					- 重复包含头文件：如：在自己写的一个头文件中包含了iostream，然后在main函数cpp文件中又包含了iostream。这就是重复包含。
					- 确保头文件多次包含仍能安全工作的常用技术是预处理器（preprocessor）
					- C++程序还会用到的一项预处理功能是头文件保护符（header guard），头文件保护符依赖于预处理变量。预处理变量有两种状态：已定义和未定义。#define指令把一个名字设定为预处理变量，另外两个指令则分别检查某个指定的预处理变量是否已经定义：#ifdef当且仅当变量已定义时为真，#ifndef当且仅当变量未定义时为真。一旦检查结果为真，则执行后续操作直至遇到#endif指令为止。
						- ```cpp
						  #ifndef SALES_DATA_H
						  #define SALES_DATA_H
						  #include<string>
						  ...
						  #enif
						  ```
					- 第一次包含该文件时，检查\#ifndef为真，预处理器将顺序执行后面的操作，直至遇到\#enif为止。后面再次包含该文件时，ifndef为假，编译器会跳过后面的操作。
					- 整个程序中的预处理变量包括头文件保护符必须唯一，通常的做法是基于头文件中类的名字来构建保护符的名字，以确保其唯一性。为了避免与程序中的其他实体发生名字冲突，一般把预处理变量的名字全部大写。